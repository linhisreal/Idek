'use strict';

module.exports = async (channel) => {
    try {
        // Cache frequently used operations
        const formatDate = (timestamp) => new Date(timestamp).toLocaleString();
        
        // Define styling for the HTML transcript - Use template literals more efficiently
        const style = `
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
                font-family: 'Whitney', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            }
            
            body {
                background-color: #36393f;
                color: #dcddde;
                padding: 20px;
                max-width: 1000px;
                margin: 0 auto;
            }
            
            .transcript-header {
                display: flex;
                align-items: center;
                margin-bottom: 20px;
                padding-bottom: 20px;
                border-bottom: 1px solid #40444b;
            }
            
            .transcript-header img {
                width: 50px;
                height: 50px;
                border-radius: 50%;
                margin-right: 15px;
            }
            
            .transcript-header h1 {
                color: white;
                font-size: 24px;
            }
            
            .transcript-info {
                color: #a3a6aa;
                margin-bottom: 30px;
            }
            
            .message-container {
                margin-bottom: 20px;
            }
            
            .message-header {
                display: flex;
                align-items: center;
                margin-bottom: 5px;
            }
            
            .message-header img {
                width: 40px;
                height: 40px;
                border-radius: 50%;
                margin-right: 15px;
            }
            
            .username {
                color: white;
                font-weight: 500;
                margin-right: 10px;
            }
            
            .timestamp {
                color: #a3a6aa;
                font-size: 12px;
            }
            
            .message-content {
                padding-left: 55px;
                margin-bottom: 5px;
                overflow-wrap: break-word;
                word-wrap: break-word;
            }
            
            .message-attachment {
                padding-left: 55px;
                margin-top: 5px;
                display: block;
            }
            
            .attachment-image {
                max-width: 400px;
                max-height: 300px;
                border-radius: 4px;
            }
            
            .attachment-file {
                display: inline-block;
                background-color: #2f3136;
                border-radius: 4px;
                padding: 10px;
                margin-top: 5px;
                color: #00aff4;
                text-decoration: none;
            }
            
            .attachment-note {
                color: #a3a6aa;
                font-size: 11px;
                margin-top: 4px;
                font-style: italic;
            
            }
            .embed {
                max-width: 520px;
                padding: 8px 10px;
                margin-top: 5px;
                background-color: #2f3136;
                border-left: 4px solid;
                border-radius: 4px;
            }
            
            .embed-author {
                display: flex;
                align-items: center;
                margin-bottom: 5px;
            }
            
            .embed-author img {
                width: 24px;
                height: 24px;
                border-radius: 50%;
                margin-right: 8px;
            }
            
            .embed-title {
                color: white;
                font-size: 16px;
                font-weight: 600;
                margin-bottom: 8px;
            }
            
            .embed-description {
                color: #dcddde;
                margin-bottom: 8px;
                font-size: 14px;
            }
            
            .embed-fields {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 8px;
                margin: 8px 0;
            }
            
            .embed-field {
                margin-bottom: 8px;
            }
            
            .field-name {
                color: white;
                font-size: 14px;
                font-weight: 600;
                margin-bottom: 2px;
            }
            
            .field-value {
                color: #dcddde;
                font-size: 14px;
            }
            
            .embed-footer {
                display: flex;
                align-items: center;
                margin-top: 8px;
                color: #a3a6aa;
                font-size: 12px;
            }
            
            .embed-footer img {
                width: 20px;
                height: 20px;
                border-radius: 50%;
                margin-right: 8px;
            }
            
            .embed-image img {
                max-width: 500px;
                max-height: 300px;
                margin-top: 8px;
                border-radius: 4px;
            }
            
            .embed-thumbnail {
                float: right;
            }
            
            .embed-thumbnail img {
                max-width: 80px;
                max-height: 80px;
                border-radius: 4px;
            }
            
            .system-message {
                padding: 8px 12px;
                background-color: #2f3136;
                border-radius: 4px;
                margin-bottom: 15px;
                text-align: center;
                font-size: 14px;
                color: #a3a6aa;
            }
            
            .bot-tag {
                background-color: #5865f2;
                color: white;
                padding: 1px 4px;
                border-radius: 3px;
                font-size: 10px;
                margin-left: 5px;
                vertical-align: middle;
            }
            
            ::-webkit-scrollbar {
                width: 8px;
            }
            
            ::-webkit-scrollbar-track {
                background-color: #2f3136;
            }
            
            ::-webkit-scrollbar-thumb {
                background-color: #202225;
                border-radius: 4px;
            }
            
            code {
                background-color: #2f3136;
                padding: 3px 5px;
                border-radius: 3px;
                font-family: Consolas, 'Courier New', monospace;
            }
            
            pre {
                background-color: #2f3136;
                padding: 8px;
                border-radius: 4px;
                margin: 5px 0;
                font-family: Consolas, 'Courier New', monospace;
                white-space: pre-wrap;
            }
            
            /* Add a print-friendly media query */
            @media print {
                body {
                    background-color: white;
                    color: black;
                }
                .embed {
                    border: 1px solid #ccc;
                    print-color-adjust: exact;
                    -webkit-print-color-adjust: exact;
                }
                /* More print styles... */
            }
            
            /* Add responsive styles for mobile */
            @media (max-width: 768px) {
                body {
                    padding: 10px;
                }
                .message-content {
                    padding-left: 15px;
                }
                .attachment-image {
                    max-width: 100%;
                }
            }

            .transcript-nav {
                position: sticky;
                top: 0;
                background-color: #2f3136;
                padding: 10px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                z-index: 100;
                border-radius: 4px;
                margin-bottom: 15px;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            }

            .transcript-nav .controls {
                display: flex;
                gap: 10px;
            }

            .transcript-nav button {
                background-color: #4f545c;
                border: none;
                color: white;
                padding: 5px;
                border-radius: 4px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: background-color 0.2s;
            }

            .transcript-nav button:hover {
                background-color: #5d6269;
            }

            .search-container {
                display: flex;
                align-items: center;
                gap: 5px;
            }

            #searchInput {
                background-color: #40444b;
                border: none;
                padding: 5px 10px;
                border-radius: 3px;
                color: white;
                font-size: 14px;
                width: 200px;
            }

            #searchCount {
                color: #b9bbbe;
                font-size: 12px;
                margin: 0 5px;
                min-width: 60px;
                text-align: center;
            }

            .search-highlight {
                background-color: rgba(255, 255, 0, 0.3);
                border-radius: 2px;
            }

            .search-highlight-active {
                background-color: rgba(255, 165, 0, 0.5);
                border-radius: 2px;
            }

            /* Light mode styles */
            body.light-mode {
                background-color: #ffffff;
                color: #2e3338;
            }

            body.light-mode .transcript-header h1 {
                color: #060607;
            }

            body.light-mode .username {
                color: #060607;
            }

            body.light-mode .transcript-nav {
                background-color: #f2f3f5;
            }

            body.light-mode .transcript-nav button {
                background-color: #e3e5e8;
                color: #4f5660;
            }

            body.light-mode .transcript-nav button:hover {
                background-color: #d4d7dc;
            }

            body.light-mode #searchInput {
                background-color: #e3e5e8;
                color: #2e3338;
            }

            body.light-mode .system-message {
                background-color: #f2f3f5;
                color: #747f8d;
            }

            body.light-mode .embed {
                background-color: #f2f3f5;
            }

            body.light-mode code {
                background-color: #e3e5e8;
            }

            body.light-mode pre {
                background-color: #e3e5e8;
            }

            body.light-mode .message-content a {
                color: #00b0f4;
            }

            body.light-mode .image-attachment-link {
                background-color: rgba(242, 243, 245, 0.6);
                border: 1px solid rgba(79, 84, 92, 0.2);
            }

            body.light-mode .attachment-note {
                color: #747f8d;
            
            }
            /* Timestamp formatting */
            .timestamp-relative {
                font-size: 0.75rem;
                color: #72767d;
                margin-left: 0.5rem;
            }

            /* Jump buttons for long transcripts */
            .jump-section {
                position: fixed;
                bottom: 20px;
                right: 20px;
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            /* Avatar and image hover effects */
            .message-header img:hover {
                transform: scale(1.2);
                transition: transform 0.2s ease;
            }

            .attachment-image:hover {
                opacity: 0.9;
            }

            /* Message hover highlight */
            .message-container:hover {
                background-color: rgba(79, 84, 92, 0.16);
                border-radius: 4px;
            }

            body.light-mode .message-container:hover {
                background-color: rgba(220, 221, 222, 0.3);
            }

            /* Component styling */
            .message-components {
                padding-left: 55px;
                margin-top: 4px;
                margin-bottom: 4px;
            }

            .component-row {
                display: flex;
                gap: 4px;
                margin-bottom: 4px;
            }

            .component-button {
                display: inline-flex;
                align-items: center;
                padding: 2px 16px;
                border-radius: 3px;
                font-size: 14px;
                font-weight: 500;
                background-color: #4f545c;
                color: white;
                cursor: not-allowed;
                opacity: 0.7;
            }

            .component-select {
                display: inline-flex;
                align-items: center;
                padding: 2px 16px;
                border-radius: 3px;
                font-size: 14px;
                background-color: #2f3136;
                color: white;
                cursor: not-allowed;
                opacity: 0.7;
                min-width: 150px;
            }

            /* Attachment styling improvements */
            .attachment-wrapper {
                position: relative;
                display: inline-block;
            }

            .attachment-info {
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                background-color: rgba(0, 0, 0, 0.7);
                color: white;
                padding: 4px 8px;
                font-size: 12px;
                opacity: 0;
                transition: opacity 0.2s;
            }

            .attachment-wrapper:hover .attachment-info {
                opacity: 1;
            }

            .attachment-name {
                display: block;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            /* Table of contents */
            .transcript-toc {
                background-color: #2f3136;
                border-radius: 4px;
                padding: 10px;
                margin-bottom: 20px;
                max-height: 200px;
                overflow-y: auto;
            }

            .transcript-toc h2 {
                color: white;
                font-size: 16px;
                margin-bottom: 10px;
            }

            .toc-entry {
                margin-bottom: 4px;
            }

            .toc-entry a {
                color: #00aff4;
                text-decoration: none;
            }

            .toc-entry a:hover {
                text-decoration: underline;
            }

            /* Jump section */
            .jump-section {
                position: fixed;
                bottom: 20px;
                right: 20px;
                display: flex;
                flex-direction: column;
                gap: 10px;
                z-index: 100;
            }

            .jump-button {
                width: 40px;
                height: 40px;
                display: flex;
                align-items: center;
                justify-content: center;
                background-color: #4f545c;
                border-radius: 50%;
                color: white;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
                cursor: pointer;
                opacity: 0.7;
                transition: opacity 0.2s;
            }

            .jump-button:hover {
                opacity: 1;
            }

            /* Discord-specific formatting styles */
            .spoiler {
                background-color: #202225;
                color: transparent;
                cursor: pointer;
                padding: 0 2px;
                border-radius: 3px;
            }
            
            .spoiler:hover, 
            .spoiler.revealed {
                background-color: rgba(32, 34, 37, 0.5);
                color: #dcddde;
            }
            
            blockquote {
                border-left: 4px solid #4f545c;
                padding-left: 8px;
                margin: 4px 0;
                color: #b9bbbe;
            }
            
            pre {
                background-color: #2f3136;
                padding: 8px;
                border-radius: 4px;
                margin: 5px 0;
                font-family: Consolas, 'Courier New', monospace;
                white-space: pre-wrap;
                max-width: 90%;
                overflow-x: auto;
            }
            
            code {
                background-color: #2f3136;
                padding: 3px 5px;
                border-radius: 3px;
                font-family: Consolas, 'Courier New', monospace;
                font-size: 85%;
                white-space: pre-wrap;
            }
            
            pre code {
                background-color: transparent;
                padding: 0;
                white-space: pre-wrap;
                display: block;
            }
            
            .mention {
                background-color: rgba(88, 101, 242, 0.3);
                color: #dee0fc;
                padding: 0 2px;
                border-radius: 3px;
                font-weight: 500;
            }
            
            .mention:hover {
                background-color: rgba(88, 101, 242, 0.6);
            }
            
            /* Light mode styles for these elements */
            body.light-mode .spoiler {
                background-color: #e5e5e5;
            }
            
            body.light-mode .spoiler:hover,
            body.light-mode .spoiler.revealed {
                background-color: rgba(229, 229, 229, 0.5);
                color: #2e3338;
            }
            
            body.light-mode blockquote {
                border-left-color: #c4c9ce;
                color: #747f8d;
            }
            
            body.light-mode pre,
            body.light-mode code {
                background-color: #f2f3f5;
            }
            
            body.light-mode .mention {
                background-color: rgba(88, 101, 242, 0.15);
                color: #5865f2;
            }
            
            /* Timestamp formatting */
            .timestamp {
                color: #72767d;
                font-size: 0.85em;
            }
            
            body.light-mode .timestamp {
                color: #747f8d;
            }
            
            /* Additional styles for lists */
            ul {
                margin-left: 20px;
                list-style-type: disc;
            }
            
            ol {
                margin-left: 20px;
                list-style-type: decimal;
            }

            /* Discord emoji styling */
            .discord-emoji {
                width: 1.375em;
                height: 1.375em;
                vertical-align: bottom;
                object-fit: contain;
            }

            /* Reaction styling */
            .message-reactions {
                display: flex;
                flex-wrap: wrap;
                gap: 4px;
                padding-left: 55px;
                margin-top: 4px;
            }

            .reaction {
                background-color: rgba(79, 84, 92, 0.16);
                border-radius: 4px;
                display: flex;
                align-items: center;
                padding: 0 6px;
                height: 24px;
            }

            .reaction-emoji {
                width: 16px;
                height: 16px;
                margin-right: 4px;
                vertical-align: bottom;
            }

            .reaction-count {
                font-size: 0.85em;
                color: #b9bbbe;
            }

            body.light-mode .reaction {
                background-color: rgba(79, 84, 92, 0.08);
            }

            body.light-mode .reaction-count {
                color: #4f5660;
            }

            /* Improved Discord emoji styling */
            .discord-emoji {
                width: 1.375em;
                height: 1.375em;
                vertical-align: bottom;
                object-fit: contain;
                display: inline-block;
            }

            /* Improved reaction styling */
            .reaction {
                background-color: rgba(79, 84, 92, 0.16);
                border-radius: 4px;
                display: flex;
                align-items: center;
                padding: 0 6px;
                height: 24px;
            }

            .reaction-emoji {
                width: 16px;
                height: 16px;
                margin-right: 4px;
                vertical-align: middle;
                display: inline-block;
            }

            .embed-gif a.embed-link:hover {
                text-decoration: underline;
            }

            /* Better GIF styling to fix rendering issues */
            .attachment-gif {
                max-width: 400px;
                max-height: 300px;
                border-radius: 4px;
                display: block;
                object-fit: contain;
                background: rgba(0, 0, 0, 0.05); /* Subtle background while loading */
            }

            /* Better GIF handling */
            .embed-gif {
                margin: 8px 0;
                display: block;
                background: rgba(0, 0, 0, 0.03);
                border-radius: 4px;
                padding: 2px;
                max-width: 100%;
            }

            .embed-gif img {
                max-width: 100%;
                max-height: 300px;
                border-radius: 4px;
                display: block;
                object-fit: contain;
                margin: 0 auto;
            }  

            .embed-gif a.embed-link {
                display: inline-block;
                color: #00aff4;
                text-decoration: none;
                margin-top: 4px;
                font-size: 0.9em;
            }

            .gif-placeholder {
                max-width: 400px;
                transition: all 0.3s ease;
            }

            .embed-gif a.embed-link:hover {
                text-decoration: underline;
            }

            .image-attachment-link {
                display: flex;
                flex-direction: column;
                padding: 10px;
                border-radius: 4px;
                background-color: rgba(47, 49, 54, 0.6);
                border: 1px solid rgba(79, 84, 92, 0.3);
                margin-top: 5px;
            }

            .image-attachment-link a {
                color: #00aff4;
                text-decoration: none;
                font-weight: 500;
            }

            .image-attachment-link a:hover {
                text-decoration: underline;
            }

            body.light-mode .image-attachment-link {
                background-color: rgba(242, 243, 245, 0.6);
                border: 1px solid rgba(79, 84, 92, 0.2);
            }

            body.light-mode .attachment-note {
                color: #747f8d;
            }

            .embed-image-link {
                padding: 10px;
                margin: 5px 0;
                border-radius: 4px;
                background-color: rgba(47, 49, 54, 0.6);
                border: 1px solid rgba(79, 84, 92, 0.3);
            }

            .embed-image-link a {
                color: #00aff4;
                text-decoration: none;
                font-weight: 500;
                display: block;
            }

            .embed-image-link a:hover {
                text-decoration: underline;
            }

            body.light-mode .embed-image-link {
                background-color: rgba(242, 243, 245, 0.6);
                border: 1px solid rgba(79, 84, 92, 0.2);
            }
        </style>`;

        // Add these helper functions to your module scope

        // Cache for user/channel name lookups
        const mentionCache = {
            users: new Map(),
            channels: new Map(),
            roles: new Map()
        };

        // Helper to find username from userId
        function getUsernameFromId(userId) {
            // If already in cache, return it
            if (mentionCache.users.has(userId)) {
                return mentionCache.users.get(userId);
            }
            
            try {
                // Try to get from client cache if available
                if (channel.client && channel.client.users.cache.has(userId)) {
                    const user = channel.client.users.cache.get(userId);
                    mentionCache.users.set(userId, user.username);
                    return user.username;
                }
                
                // Otherwise return null and let the caller use a default
                return null;
            } catch (error) {
                console.error('[TRANSCRIPT]: Error getting username for ID', userId, error);
                return null;
            }
        }

        // Helper to find channel name from channelId
        function getChannelNameFromId(channelId) {
            // If already in cache, return it
            if (mentionCache.channels.has(channelId)) {
                return mentionCache.channels.get(channelId);
            }
            
            try {
                // Try to get from client cache if available
                if (channel.client && channel.client.channels.cache.has(channelId)) {
                    const foundChannel = channel.client.channels.cache.get(channelId);
                    mentionCache.channels.set(channelId, foundChannel.name);
                    return foundChannel.name;
                }
                
                // Otherwise return null and let the caller use a default
                return null;
            } catch (error) {
                console.error('[TRANSCRIPT]: Error getting channel name for ID', channelId, error);
                return null;
            }
        }

        // Helper to find role name from roleId
        function getRoleNameFromId(roleId) {
            // If already in cache, return it
            if (mentionCache.roles.has(roleId)) {
                return mentionCache.roles.get(roleId);
            }
            
            try {
                // Try to get from client cache if available
                if (channel.guild && channel.guild.roles.cache.has(roleId)) {
                    const role = channel.guild.roles.cache.get(roleId);
                    mentionCache.roles.set(roleId, role.name);
                    return role.name;
                }
                
                // Otherwise return null and let the caller use a default
                return null;
            } catch (error) {
                console.error('[TRANSCRIPT]: Error getting role name for ID', roleId, error);
                return null;
            }
        }

        // Function to process Discord custom emoji
        function processDiscordEmoji(content) {
            return content.replace(/&lt;(a)?:([a-zA-Z0-9_]+):(\d+)&gt;/g, (match, animated, name, id) => {
                const extension = animated ? 'gif' : 'png';
                const emojiUrl = `https://cdn.discordapp.com/emojis/${id}.${extension}`;
                
                return `<img class="discord-emoji" src="${emojiUrl}" alt=":${name}:" title=":${name}:" onerror="this.onerror=null;this.style.display='none';this.parentNode.insertAdjacentText('beforeend', ':${name}:');">`;
            });
        }

        // More comprehensive markdown conversion with better Discord formatting support
        function markdownToHTML(text) {
            if (!text) return '';
            
            try {
                // First escape HTML characters to prevent injection
                let html = text
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
                
                // Process Discord custom emoji
                html = processDiscordEmoji(html);
                
                // Code blocks with language highlighting
                html = html.replace(/```([a-zA-Z0-9_-]*)\n([\s\S]*?)```/g, (match, language, code) => {
                    const lang = language ? ` class="language-${language.trim()}"` : '';
                    return `<pre><code${lang}>${code}</code></pre>`;
                });
                
                // Inline code
                html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
                
                // Multiline quote blocks (Discord uses > at beginning of each line)
                html = html.replace(/(^|\\n)&gt; ([^\n]+)/gm, (match, start, content) => {
                    return `${start}<blockquote>${content}</blockquote>`;
                });
                
                // Bold
                html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                
                // Underline (Discord uses __ for underline)
                html = html.replace(/__(.*?)__/g, '<u>$1</u>');
                
                // Italics (both * and _ versions)
                html = html.replace(/\*([^*]+)\*/g, '<em>$1</em>');
                html = html.replace(/_([^_]+)_/g, '<em>$1</em>');
                
                // Strikethrough (Discord uses ~~ for strikethrough)
                html = html.replace(/~~(.*?)~~/g, '<s>$1</s>');
                
                // Spoiler tags (Discord uses || for spoilers)
                html = html.replace(/\|\|(.*?)\|\|/g, '<span class="spoiler">$1</span>');
                
                // User mentions (Discord uses <@USER_ID> or <@!USER_ID>)
                html = html.replace(/&lt;@!?(\d+)&gt;/g, (match, userId) => {
                    try {
                        // Try to find username from message authors in the transcript
                        const username = getUsernameFromId(userId);
                        if (username) {
                            return `<span class="mention user-mention" data-user-id="${userId}">@${username}</span>`;
                        }
                        
                        // If there's a client with user cache, try to get from there
                        if (channel.client && channel.client.users.cache.has(userId)) {
                            const user = channel.client.users.cache.get(userId);
                            return `<span class="mention user-mention" data-user-id="${userId}">@${user.username}</span>`;
                        }
                    } catch (err) {
                        console.error('[TRANSCRIPT]: Error processing user mention:', err);
                    }
                    
                    // If all else fails, just show @User with ID
                    return `<span class="mention user-mention" data-user-id="${userId}">@User</span>`;
                });

                // Channel mentions (Discord uses <#CHANNEL_ID>)
                html = html.replace(/&lt;#(\d+)&gt;/g, (match, channelId) => {
                    try {
                        // Try to find channel name from the transcript
                        const channelName = getChannelNameFromId(channelId);
                        if (channelName) {
                            return `<span class="mention channel-mention" data-channel-id="${channelId}">#${channelName}</span>`;
                        }
                        
                        // If there's a client with channel cache, try to get from there
                        if (channel.client && channel.client.channels.cache.has(channelId)) {
                            const foundChannel = channel.client.channels.cache.get(channelId);
                            return `<span class="mention channel-mention" data-channel-id="${channelId}">#${foundChannel.name}</span>`;
                        }
                    } catch (err) {
                        console.error('[TRANSCRIPT]: Error processing channel mention:', err);
                    }
                    
                    // If all else fails
                    return `<span class="mention channel-mention" data-channel-id="${channelId}">#channel</span>`;
                });

                // Role mentions (Discord uses <@&ROLE_ID>)
                html = html.replace(/&lt;@&(\d+)&gt;/g, (match, roleId) => {
                    // Try to find role name from the transcript
                    const roleName = getRoleNameFromId(roleId) || 'role';
                    return `<span class="mention role-mention" data-role-id="${roleId}">@${roleName}</span>`;
                });
                
                // Timestamp formatting (<t:TIMESTAMP:FORMAT>)
                html = html.replace(/&lt;t:(\d+):[tTdDfFR]&gt;/g, (match, timestamp) => {
                    try {
                        const date = new Date(parseInt(timestamp) * 1000);
                        return `<span class="timestamp" title="${date.toLocaleString()}">${date.toLocaleString()}</span>`;
                    } catch {
                        return match;
                    }
                });
                
                // URL auto-linking (only if not already linked)
                html = html.replace(/(https?:\/\/[^\s<]+)(?![^<]*>|[^<>]*<\/a>)/g, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
                
                // Convert newlines to <br> tags
                html = html.replace(/\n/g, '<br>');

                // Fix the heading regex patterns
                html = html.replace(/^# (.*?)$/gm, '<h1>$1</h1>');
                html = html.replace(/^## (.*?)$/gm, '<h2>$1</h2>');
                html = html.replace(/^### (.*?)$/gm, '<h3>$1</h3>');
                
                return html;
            } catch (error) {
                console.error('[TRANSCRIPT]: Error processing markdown:', error);
                return text ? escapeHTML(text) : '';
            }
        }

        // Create embed HTML that better matches Discord's actual formats
        function createEmbed(embed) {
            if (!embed) return '<div class="embed">[Empty Embed]</div>';
            
            try {
                // Set default color if not provided or if it's a special embed type
                let colorHex = '#5865F2'; // Discord's default blue
                
                // Handle rich embed color
                if (embed.color) {
                    colorHex = `#${embed.color.toString(16).padStart(6, '0')}`;
                }
                
                // Check for special embed types
                let isSpecialEmbed = false;
                let specialEmbedType = '';
                
                // Detect special embed types (links, images, videos, etc.)
                if (embed.type) {
                    if (embed.type === 'rich') {
                        // Standard rich embed - already handled
                    } else if (embed.type === 'image' && embed.url) {
                        isSpecialEmbed = true;
                        specialEmbedType = 'image';
                    } else if (embed.type === 'video' && embed.url) {
                        isSpecialEmbed = true;
                        specialEmbedType = 'video';
                    } else if (embed.type === 'gifv' && embed.url) {
                        isSpecialEmbed = true;
                        specialEmbedType = 'gif';
                    } else if (['link', 'article'].includes(embed.type)) {
                        isSpecialEmbed = true;
                        specialEmbedType = 'link';
                    }
                }
                
                // Special handling for proxy URLs - fix for deleted/inaccessible images
                function getBackupImageUrl(originalUrl, proxyUrl) {
                    if (!originalUrl) return null;
                    
                    // Try the proxy URL first if available
                    if (proxyUrl) {
                        return `${proxyUrl}`;
                    }
                    
                    // If no proxy available, use the original
                    return originalUrl;
                }
                
                let embedHTML = `<div class="embed" style="border-left-color: ${colorHex};">`;
                
                // Special embed types
                if (isSpecialEmbed) {
                    switch (specialEmbedType) {
                        case 'image': 
                            if (embed.thumbnail && embed.thumbnail.url) {
                                embedHTML += `
                                    <div class="embed-image-link">
                                        <a href="${embed.url || embed.thumbnail.url}" target="_blank" rel="noopener">
                                            🖼️ View Original Image
                                        </a>
                                        <div class="attachment-note">Image may no longer be available in closed tickets</div>
                                    </div>`;
                            }
                            break;
                        case 'video':
                            embedHTML += `
                                <div class="embed-rich-link">
                                    <div class="embed-title">${embed.title ? markdownToHTML(embed.title) : 'Video'}</div>
                                    ${embed.description ? `<div class="embed-description">${markdownToHTML(embed.description)}</div>` : ''}
                                    <div class="embed-video-container">
                                        <div class="embed-video-placeholder">
                                            ${embed.thumbnail ? `<img src="${getBackupImageUrl(embed.thumbnail.url, embed.thumbnail.proxyURL)}" 
                                                 alt="Video thumbnail"
                                                 onerror="this.onerror=null;this.src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEABAMAAACuXLVVAAAAMFBMVEUzMzM+Pj5VVVVAQEA6OjoAAAA3NzfR0dFKSkpNTU3d3d1SUlJERERYWFhra2s0NDTKimD7AAAFLUlEQVR42u3dTW/bNhgAYFt2bCVZlqZ16wf2hXVbD9mEAT30J+wQrD10t6Jde+lP35eUZMmJDdTJegqCxg0gSnxIPqRIWuTm5ubm5ubm5ubm5ubm5jj99a9X/Sut3uz/+79XvX/6u1//qT1P/f0hWk9Rv/vwaQpN/QPAmFG/++Nb0bSgn+BHsl706VsMGvS7P3/A6lO/lfK19P0ZXP+Zufpa+Cr8Ap9w0O9++gZeP7KfJCr1k5Px/KDf/fIVvX5wu0XlJL0P4PXjH+D6yXBfnTLSTOMvwPWTwPptFpKtTF5BvwDrV4Q0htWvM4nLLwyuv2vAJuq3Z22C9ZOhlM86UL/95I5R9euMlk9A/ShnQPVXCRjXN9A5Bvrd7y+g+oexSS6A+mGB+lmWrYH1r+75tQHU37fYg+AAt1HtyabaEQzgNqq/C8Edwr5ZAvXTAOjWQw6TQJddgOsfN+EaTCfddQt0Q6H+Pp9K2IfAIKA7j/X302GbDUPgNwr1DzfoGuoQ2ILqH28B5ynZbJxW8OmkFz2RBIW3PQqmBXwi7cbNj7YI9y3VcANAFyQ0UXObYB9sj2HCNARGt1ENbxDgm2jSgt1izKbZZWiA7jao4Q0CbBfVGNOCcD0KhkOg/SYKDQLtNtFhnrgcBpuhvoG2m+huRkA3gxfPAPTLIUQGQR8Cs2VsExwEfQjMMFUcvuEeBAcBwd+8P9hvopuhn7Abv+EaBH0ITPAM3unHXv0b3s+h+gU0BIY3UU9f4Nto/QyuGa0/Syb4Bqo9MQTG12h9na8V1E4QvMcGQe0J0APoz3XiLzXUTrJfozfR+hk0BBrehvLsCAr7GD1G65cfQQOuAZYT0/bcUNnTG/b8H0KPr/B/oWmhY7T+UgDJ2hZ6jNdfiiQpW2iI118tgT3XQppSAJssuwBa6LO0+Oa5JEHQEvScJmRo/cUAOpiNQ+ubInULPUbrL++4npeFgz5nr3BloNPc3ECHpWQpy7HjQOCR6zqNefjKwl9yLwQs+Z8sLV7S4vtNljqb1+9ekx93W9DhZULQznKfIFn0CQc22V0Eem8vmcpVuvpmk4FOr+HmyVKulkkCqaBH68Bfy9k6kElwacKmBSjTArQPTNzrQaT+KJfo5FsH/CwHvlM35Ec0XyQQaK0DxcsSHU3TyYXIj0COAdkVggakG0QMZPjTSgGiKwQNZGsJhD1IBAyUGSzTVpBc2oAcmjcZgYCBH0omraCB4g5Ffh8MQHKHgLqPCB2A2jQcAPuXGuJPd8AYoFLowcg3bgDa0wnGQFYzIYCr8u4GMm3gyyI9uAFcGnUDuUhybyAUGykHVhVnYFVZEgD1514Z6Y8ZYFJ5vTLSLzFQcUDm9kC/xACRAyr2Z/SLDNDLHzob0C81MF+FDQzXIQOLVdDAch00sFoHDCxqfsmXiQLG++IrcTr7oE7nAwZUPmgg9/rFx6lmHzKged3AZF94rB4UNGDyoLbcShjQvDYgK0EDGtcGZB4yYHNtIBP26fdnppABiWgDTk8ZMHRiQO4iBoyaMhD07P+xgSxgwOZhA1arDFi7l5ABQ/e1AbMOGbB0YkDuAgasnDJg1KQBWxsD432xgXwfMmDohIFMSQtd149yfoYyfmbKQJSnDORRzk9Tfp7287QbaO5PUobOErbQ9PuYZfhM5ecp39+FzlOerwuf53xfHzxPer5BcJ70fZPwPO37NvF54uc2g++iwfeNwvO075vF58l/twvP8/9uGJ5n+N00PM/xu2143Tc3Nzc3Nzc3N7f/Af4HYsoSvpYpIKMAAAAASUVORK5CYII=';">` : ''}
                                            <div class="embed-video-play-button">▶</div>
                                        </div>
                                        <a href="${embed.url}" target="_blank" rel="noopener" class="embed-link">Video Link</a>
                                    </div>
                                </div>`;
                            break;
                        case 'gif':
                            embedHTML += `
                                <div class="embed-gif">
                                    <img src="${embed.url || embed.thumbnail?.url}" alt="Animated GIF" data-is-gif="true" style="max-width:100%;">
                                    <a href="${embed.url}" target="_blank" rel="noopener" class="embed-link">
                                        🎞️ View Original GIF
                                    </a>
                                    <div class="attachment-note">GIF may no longer be available in closed tickets</div>
                                </div>`;
                            break;
                        case 'link':
                            embedHTML += `
                                <div class="embed-rich-link">
                                    ${embed.provider?.name ? `<div class="embed-provider">${escapeHTML(embed.provider.name)}</div>` : ''}
                                    ${embed.author?.name ? `<div class="embed-author">${escapeHTML(embed.author.name)}</div>` : ''}
                                    <a href="${embed.url}" target="_blank" rel="noopener" class="embed-title-link">
                                        ${embed.title ? markdownToHTML(embed.title) : embed.url}
                                    </a>
                                    ${embed.description ? `<div class="embed-description">${markdownToHTML(embed.description)}</div>` : ''}
                                    ${embed.thumbnail?.url ? `
                                        <div class="embed-thumbnail">
                                            <img src="${getBackupImageUrl(embed.thumbnail.url, embed.thumbnail.proxyURL)}" alt="Link thumbnail"
                                                 onerror="this.onerror=null;this.style.display='none';">
                                        </div>` : ''}
                                </div>`;
                            break;
                        default:
                            // Use regular rich embed rendering for unknown types
                            isSpecialEmbed = false;
                    }
                }
                
                // Standard rich embed if not a special type
                if (!isSpecialEmbed) {
                    // Author
                    if (embed.author) {
                        embedHTML += '<div class="embed-author">';
                        if (embed.author.iconURL || embed.author.icon_url) {
                            const iconUrl = getBackupImageUrl(embed.author.iconURL || embed.author.icon_url, 
                                                            embed.author.proxyIconURL || embed.author.proxy_icon_url);
                            embedHTML += `<img src="${iconUrl}" alt="Author Icon" onerror="this.style.display='none';">`;
                        }
                        embedHTML += `<span style="color: white;">${escapeHTML(embed.author.name || '')}</span>`;
                        embedHTML += '</div>';
                    }
                    
                    // Title with optional URL
                    if (embed.title) {
                        if (embed.url) {
                            embedHTML += `<a href="${embed.url}" target="_blank" rel="noopener" class="embed-title-link">
                                             <div class="embed-title">${markdownToHTML(embed.title)}</div>
                                         </a>`;
                        } else {
                            embedHTML += `<div class="embed-title">${markdownToHTML(embed.title)}</div>`;
                        }
                    }
                    
                    // Description
                    if (embed.description) {
                        embedHTML += `<div class="embed-description">${markdownToHTML(embed.description)}</div>`;
                    }
                    
                    // Thumbnail
                    if (embed.thumbnail && embed.thumbnail.url) {
                        const thumbUrl = getBackupImageUrl(embed.thumbnail.url, embed.thumbnail.proxyURL);
                        embedHTML += `<div class="embed-thumbnail">
                                        <img src="${thumbUrl}" alt="Thumbnail" onerror="this.onerror=null;this.style.display='none';">
                                      </div>`;
                    }
                    
                    // Fields
                    if (embed.fields && Array.isArray(embed.fields) && embed.fields.length > 0) {
                        // Check if all fields are inline
                        const allInline = embed.fields.every(f => f && f.inline === true);
                        embedHTML += `<div class="embed-fields" style="grid-template-columns: ${allInline ? 'repeat(3, 1fr)' : 'repeat(1, 1fr)'}">`;
                        
                        embed.fields.forEach(field => {
                            if (!field || !field.name) return; // Skip invalid fields
                            
                            embedHTML += `<div class="embed-field" ${field.inline === false ? 'style="grid-column: 1 / -1;"' : ''}>`;
                            embedHTML += `<div class="field-name">${markdownToHTML(field.name)}</div>`;
                            embedHTML += `<div class="field-value">${markdownToHTML(field.value || '')}</div>`;
                            embedHTML += '</div>';
                        });
                        
                        embedHTML += '</div>';
                    }
                    
                    // Image
                    if (embed.image && embed.image.url) {
                        const imageUrl = getBackupImageUrl(embed.image.url, embed.image.proxyURL);
                        embedHTML += `<div class="embed-image">
                                        <img src="${imageUrl}" alt="Embed Image" 
                                             onerror="this.onerror=null;this.src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEABAMAAACuXLVVAAAAMFBMVEUzMzM+Pj5VVVVAQEA6OjoAAAA3NzfR0dFKSkpNTU3d3d1SUlJERERYWFhra2s0NDTKimD7AAAFLUlEQVR42u3dTW/bNhgAYFt2bCVZlqZ16wf2hXVbD9mEAT30J+wQrD10t6Jde+lP35eUZMmJDdTJegqCxg0gSnxIPqRIWuTm5ubm5ubm5ubm5ubm5jj99a9X/Sut3uz/+79XvX/6u1//qT1P/f0hWk9Rv/vwaQpN/QPAmFG/++Nb0bSgn+BHsl706VsMGvS7P3/A6lO/lfK19P0ZXP+Zufpa+Cr8Ap9w0O9++gZeP7KfJCr1k5Px/KDf/fIVvX5wu0XlJL0P4PXjH+D6yXBfnTLSTOMvwPWTwPptFpKtTF5BvwDrV4Q0htWvM4nLLwyuv2vAJuq3Z22C9ZOhlM86UL/95I5R9euMlk9A/ShnQPVXCRjXN9A5Bvrd7y+g+oexSS6A+mGB+lmWrYH1r+75tQHU37fYg+AAt1HtyabaEQzgNqq/C8Edwr5ZAvXTAOjWQw6TQJddgOsfN+EaTCfddQt0Q6H+Pp9K2IfAIKA7j/X302GbDUPgNwr1DzfoGuoQ2ILqH28B5ynZbJxW8OmkFz2RBIW3PQqmBXwi7cbNj7YI9y3VcANAFyQ0UXObYB9sj2HCNARGt1ENbxDgm2jSgt1izKbZZWiA7jao4Q0CbBfVGNOCcD0KhkOg/SYKDQLtNtFhnrgcBpuhvoG2m+huRkA3gxfPAPTLIUQGQR8Cs2VsExwEfQjMMFUcvuEeBAcBwd+8P9hvopuhn7Abv+EaBH0ITPAM3unHXv0b3s+h+gU0BIY3UU9f4Nto/QyuGa0/Syb4Bqo9MQTG12h9na8V1E4QvMcGQe0J0APoz3XiLzXUTrJfozfR+hk0BBrehvLsCAr7GD1G65cfQQOuAZYT0/bcUNnTG/b8H0KPr/B/oWmhY7T+UgDJ2hZ6jNdfiiQpW2iI118tgT3XQppSAJssuwBa6LO0+Oa5JEHQEvScJmRo/cUAOpiNQ+ubInULPUbrL++4npeFgz5nr3BloNPc3ECHpWQpy7HjQOCR6zqNefjKwl9yLwQs+Z8sLV7S4vtNljqb1+9ekx93W9DhZULQznKfIFn0CQc22V0Eem8vmcpVuvpmk4FOr+HmyVKulkkCqaBH68Bfy9k6kElwacKmBSjTArQPTNzrQaT+KJfo5FsH/CwHvlM35Ec0XyQQaK0DxcsSHU3TyYXIj0COAdkVggakG0QMZPjTSgGiKwQNZGsJhD1IBAyUGSzTVpBc2oAcmjcZgYCBH0omraCB4g5Ffh8MQHKHgLqPCB2A2jQcAPuXGuJPd8AYoFLowcg3bgDa0wnGQFYzIYCr8u4GMm3gyyI9uAFcGnUDuUhybyAUGykHVhVnYFVZEgD1514Z6Y8ZYFJ5vTLSLzFQcUDm9kC/xACRAyr2Z/SLDNDLHzob0C81MF+FDQzXIQOLVdDAch00sFoHDCxqfsmXiQLG++IrcTr7oE7nAwZUPmgg9/rFx6lmHzKged3AZF94rB4UNGDyoLbcShjQvDYgK0EDGtcGZB4yYHNtIBP26fdnppABiWgDTk8ZMHRiQO4iBoyaMhD07P+xgSxgwOZhA1arDFi7l5ABQ/e1AbMOGbB0YkDuAgasnDJg1KQBWxsD432xgXwfMmDohIFMSQtd149yfoYyfmbKQJSnDORRzk9Tfp7287QbaO5PUobOErbQ9PuYZfhM5ecp39+FzlOerwuf53xfHzxPer5BcJ70fZPwPO37NvF54uc2g++iwfeNwvO075vF58l/twvP8/9uGJ5n+N00PM/xu2143Tc3Nzc3Nzc3N7f/Af4HYsoSvpYpIKMAAAAASUVORK5CYII=';">
                                      </div>`;
                    }
                    
                    // Footer
                    if (embed.footer) {
                        embedHTML += '<div class="embed-footer">';
                        if (embed.footer.iconURL) {
                            embedHTML += `<img src="${embed.footer.iconURL}" alt="Footer Icon" onerror="this.style.display='none';">`;
                        }
                        embedHTML += `<span>${escapeHTML(embed.footer.text || '')}</span>`;
                        
                        // Timestamp
                        if (embed.timestamp) {
                            try {
                                const date = new Date(embed.timestamp);
                                embedHTML += ` • ${date.toLocaleString()}`;
                            } catch {
                                // Invalid timestamp
                            }
                        }
                        
                        embedHTML += '</div>';
                    } else if (embed.timestamp) {
                        // Just timestamp
                        try {
                            const date = new Date(embed.timestamp);
                            embedHTML += `<div class="embed-footer">${date.toLocaleString()}</div>`;
                        } catch {
                            // Invalid timestamp
                        }
                    }
                    
                    embedHTML += '</div>';
                    return embedHTML;
                }
            } catch (error) {
                console.error('[TRANSCRIPT]: Error creating embed HTML:', error);
                return '<div class="embed" style="border-left-color: #ff0000;">[Error displaying embed]</div>';
            }
        }
        
        // Safe guild icon URL retrieval 
        const guildIconURL = (() => {
            try {
                return channel.guild.iconURL({ size: 128 }) || 'https://discord.com/assets/847541504914fd33810e70a0ea73177e.ico';
            } catch {
                return 'https://discord.com/assets/847541504914fd33810e70a0ea73177e.ico';
            }
        })();

        // Fetch message count safely
        let messageCount = "Unknown";
        try {
            const msgs = await channel.messages.fetch({ limit: 1 });
            messageCount = msgs.size >= 0 ? msgs.size : "Unknown"; 
        } catch (error) {
            console.error('[TRANSCRIPT]: Failed to fetch message count:', error);
        }

        // Start building HTML with more metadata
        let html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Ticket transcript for ${escapeHTML(channel.name)}">
    <meta name="generator" content="AWPT Discord Bot">
    <title>Ticket Transcript - #${escapeHTML(channel.name)}</title>
    ${style}
</head>
<body>
    <div class="transcript-header">
        <img src="${guildIconURL}" alt="Guild Icon">
        <div>
            <h1>#${escapeHTML(channel.name)}</h1>
            <p>${escapeHTML(channel.guild.name)}</p>
        </div>
    </div>
    <div class="transcript-info">
        <p>Transcript generated on ${formatDate(Date.now())}</p>
        <p>Channel created: ${formatDate(channel.createdTimestamp)}</p>
        <p>Channel ID: ${channel.id}</p>
        <p>Total messages: ${messageCount}</p>
    </div>`;

        // Add table of contents for quick navigation
        html += `<div class="transcript-toc">
    <h2>Quick Navigation</h2>
    <div id="toc-content">
        <!-- Will be populated by JavaScript -->
    </div>
</div>`;

        html += `
    <script>
        // This will be executed when the document loads
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize transcript features
            setupTranscriptFeatures();
        });
        
        function setupTranscriptFeatures() {
            // Create navigation controls
            const nav = document.createElement('div');
            nav.className = 'transcript-nav';
            nav.innerHTML = \`
                <div class="controls">
                    <button id="darkModeToggle" title="Toggle dark/light mode">
                        <svg width="20" height="20" viewBox="0 0 24 24">
                            <path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0, 1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0,1,0.45,1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1S11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path>
                        </svg>
                    </button>
                    <button id="scrollToTop" title="Scroll to top">
                        <svg width="20" height="20" viewBox="0 0 24 24">
                            <path fill="currentColor" d="M7.41,15.41L12,10.83L16.59,15.41L18,14L12,8L6,14L7.41,15.41Z"></path>
                        </svg>
                    </button>
                    <button id="scrollToBottom" title="Scroll to bottom">
                        <svg width="20" height="20" viewBox="0 0 24 24">
                            <path fill="currentColor" d="M7.41,8.58L12,13.17L16.59,8.58L14,6L8,12L14,18L15.41,16.58Z"></path>
                        </svg>
                    </button>
                </div>
                <div class="search-container">
                    <input type="text" id="searchInput" placeholder="Search transcript...">
                    <span id="searchCount"></span>
                    <button id="prevResult" title="Previous result">
                        <svg width="16" height="16" viewBox="0 0 24 24">
                            <path fill="currentColor" d="M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z"></path>
                        </svg>
                    </button>
                    <button id="nextResult" title="Next result">
                        <svg width="16" height="16" viewBox="0 0 24 24">
                            <path fill="currentColor" d="M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z"></path>
                        </svg>
                    </button>
                </div>
            \`;
            
            document.body.insertBefore(nav, document.body.firstChild);
            
            // Set up event handlers
            document.getElementById('darkModeToggle')?.addEventListener('click', toggleDarkMode);
            document.getElementById('scrollToTop')?.addEventListener('click', () => window.scrollTo({top: 0, behavior: 'smooth'}));
            document.getElementById('scrollToBottom')?.addEventListener('click', () => window.scrollTo({top: document.body.scrollHeight, behavior: 'smooth'}));
            
            // Set up search functionality
            const searchInput = document.getElementById('searchInput');
            const searchCount = document.getElementById('searchCount');
            const prevResultBtn = document.getElementById('prevResult');
            const nextResultBtn = document.getElementById('nextResult');
            
            if (searchInput && searchCount && prevResultBtn && nextResultBtn) {
                let searchResults = [];
                let currentResultIndex = -1;
                
                searchInput.addEventListener('input', performSearch);
                prevResultBtn.addEventListener('click', () => navigateSearch(-1));
                nextResultBtn.addEventListener('click', () => navigateSearch(1));
                
                // Fix search function to handle embeds properly
                function performSearch() {
                    const searchText = searchInput.value.trim().toLowerCase();
                    if (!searchText) {
                        clearSearch();
                        return;
                    }
                    
                    // Remove previous highlighting
                    document.querySelectorAll('.search-highlight').forEach(el => {
                        try {
                            el.outerHTML = el.innerHTML;
                        } catch(e) {
                            // Fallback if outerHTML fails
                            el.classList.remove('search-highlight');
                        }
                    });
                    
                    // Find all message content but exclude embed internals
                    const contents = document.querySelectorAll('.message-content:not(.embed *):not(.embed)');
                    const embedDescriptions = document.querySelectorAll('.embed-description');
                    const embedTitles = document.querySelectorAll('.embed-title');
                    const fieldNames = document.querySelectorAll('.field-name');
                    const fieldValues = document.querySelectorAll('.field-value');
                    
                    searchResults = [];
                    
                    // Process regular message content
                    contents.forEach(content => {
                        processElementForSearch(content, searchText);
                    });
                    
                    // Process embed elements individually
                    embedTitles.forEach(title => {
                        processElementForSearch(title, searchText);
                    });
                    
                    embedDescriptions.forEach(desc => {
                        processElementForSearch(desc, searchText);
                    });
                    
                    fieldNames.forEach(name => {
                        processElementForSearch(name, searchText);
                    });
                    
                    fieldValues.forEach(value => {
                        processElementForSearch(value, searchText);
                    });
                    
                    // Helper function to process an element for search - fixed for embeds
                    function processElementForSearch(element, search) {
                        try {
                            if (element.textContent.toLowerCase().includes(search)) {
                                // Add to results
                                searchResults.push(element);
                                
                                // Use DOM manipulation rather than regex to avoid breaking HTML
                                const walker = document.createTreeWalker(
                                    element, 
                                    NodeFilter.SHOW_TEXT, 
                                    { acceptNode: node => node.nodeValue.toLowerCase().includes(search) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT }
                                );
                                
                                const nodesToReplace = [];
                                while (walker.nextNode()) {
                                    nodesToReplace.push(walker.currentNode);
                                }
                                
                                // Replace text in reverse order to avoid messing up the DOM traversal
                                for (let i = nodesToReplace.length - 1; i >= 0; i--) {
                                    const node = nodesToReplace[i];
                                    const text = node.nodeValue;
                                    const lowerText = text.toLowerCase();
                                    const startIndex = lowerText.indexOf(search);
                                    
                                    if (startIndex !== -1) {
                                        const fragment = document.createDocumentFragment();
                                        
                                        // Text before match
                                        if (startIndex > 0) {
                                            fragment.appendChild(document.createTextNode(
                                                text.substring(0, startIndex)
                                            ));
                                        }
                                        
                                        // Highlighted match
                                        const highlightSpan = document.createElement('span');
                                        highlightSpan.className = 'search-highlight';
                                        highlightSpan.textContent = text.substring(startIndex, startIndex + search.length);
                                        fragment.appendChild(highlightSpan);
                                        
                                        // Text after match
                                        if (startIndex + search.length < text.length) {
                                            fragment.appendChild(document.createTextNode(
                                                text.substring(startIndex + search.length)
                                            ));
                                        }
                                        
                                        // Replace the original text node
                                        node.parentNode.replaceChild(fragment, node);
                                    }
                                }
                            }
                        } catch(err) {
                            console.error('Error processing content for search:', err);
                        }
                    }
                    
                    // Update count display
                    searchCount.textContent = searchResults.length > 0 ? 
                        \`\${searchResults.length} found\` : 'No results';
                    
                    currentResultIndex = -1;
                    if (searchResults.length > 0) {
                        navigateSearch(1);
                    }
                }
                
                function navigateSearch(direction) {
                    if (searchResults.length === 0) return;
                    
                    // Remove active highlight
                    document.querySelectorAll('.search-highlight-active').forEach(el => {
                        el.classList.remove('search-highlight-active');
                    });
                    
                    // Move index
                    currentResultIndex += direction;
                    if (currentResultIndex >= searchResults.length) currentResultIndex = 0;
                    if (currentResultIndex < 0) currentResultIndex = searchResults.length - 1;
                    
                    // Highlight current result and scroll to it
                    try {
                        const currentElement = searchResults[currentResultIndex];
                        if (currentElement) {
                            const highlights = currentElement.querySelectorAll('.search-highlight');
                            if (highlights.length > 0) {
                                highlights[0].classList.add('search-highlight-active');
                                highlights[0].scrollIntoView({
                                    behavior: 'smooth',
                                    block: 'center'
                                });
                            }
                            
                            // Update count display
                            searchCount.textContent = \`\${currentResultIndex + 1}/\${searchResults.length}\`;
                        }
                    } catch(err) {
                        console.error('Error navigating search:', err);
                    }
                }
                
                // Also fix the clear search function to be more thorough
                function clearSearch() {
                    searchResults = [];
                    currentResultIndex = -1;
                    searchCount.textContent = '';
                    
                    // Remove all highlighting everywhere - improved to handle embeds properly
                    document.querySelectorAll('.search-highlight').forEach(el => {
                        try {
                            // Create a text node with the content
                            const textContent = document.createTextNode(el.textContent);
                            // Replace the span with the text node
                            el.parentNode.replaceChild(textContent, el);
                        } catch(e) {
                            console.error('Error clearing search highlight:', e);
                            // Fallback
                            el.classList.remove('search-highlight');
                        }
                    });
                }
            }

            // Add table of contents generation
            function generateTableOfContents() {
                try {
                    const tocContent = document.getElementById('toc-content');
                    if (!tocContent) return;
                    
                    // Find all users who sent messages
                    const users = new Map();
                    document.querySelectorAll('.message-container').forEach(container => {
                        try {
                            const userId = container.getAttribute('data-user-id');
                            const usernameEl = container.querySelector('.username');
                            if (!userId || !usernameEl) return;
                            
                            const username = usernameEl.textContent;
                            const messageId = container.id;
                            
                            if (!users.has(userId)) {
                                users.set(userId, {
                                    name: username,
                                    messageIds: []
                                });
                            }
                            
                            users.get(userId).messageIds.push(messageId);
                        } catch(err) {
                            console.error('Error processing message container for TOC:', err);
                        }
                    });
                    
                    // Generate TOC entries
                    let tocHtml = '';
                    users.forEach((user, userId) => {
                        try {
                            const firstMessageId = user.messageIds[0];
                            if (!firstMessageId) return;
                            
                            tocHtml += \`<div class="toc-entry">
                                <a href="#\${firstMessageId}">\${escapeHTML(user.name)} (\${user.messageIds.length} messages)</a>
                            </div>\`;
                        } catch(err) {
                            console.error('Error generating user TOC entry:', err);
                        }
                    });
                    
                    // Add system message entries
                    document.querySelectorAll('.system-message').forEach((msg, index) => {
                        try {
                            const messageId = \`system-msg-\${index}\`;
                            msg.id = messageId;
                            const textContent = msg.textContent?.trim() || "";
                            const displayText = textContent.length > 50 ? textContent.substring(0, 50) + "..." : textContent;
                            
                            tocHtml += \`<div class="toc-entry">
                                <a href="#\${messageId}">\${escapeHTML(displayText)}</a>
                            </div>\`;
                        } catch(err) {
                            console.error('Error generating system message TOC entry:', err);
                        }
                    });
                    
                    tocContent.innerHTML = tocHtml || '<div>No messages found</div>';
                } catch(err) {
                    console.error('Error generating table of contents:', err);
                }
            }

            // Call the TOC generator
            generateTableOfContents();
        }
        
        function toggleDarkMode() {
            try {
                document.body.classList.toggle('light-mode');
                localStorage.setItem('transcript-theme', 
                    document.body.classList.contains('light-mode') ? 'light' : 'dark');
            } catch(err) {
                console.error('Error toggling dark mode:', err);
            }
        }
        
        // Check for saved theme preference
        try {
            const savedTheme = localStorage.getItem('transcript-theme');
            if (savedTheme === 'light') {
                document.body.classList.add('light-mode');
            }
        } catch(err) {
            // Local storage might not be available
            console.error('Error checking saved theme:', err);
        }
        
        // Safely escape HTML in JavaScript
        function escapeHTML(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
`;

        // More efficient message fetching with better progress tracking
        console.log(`[TRANSCRIPT]: Starting message fetch for channel #${channel.name} (${channel.id})`);
        const fetchedMessages = [];
        let lastId = null;
        let batchNumber = 0;
        let totalFetched = 0;
        
        while (batchNumber < 5) { // 5 batches max (500 messages)
            batchNumber++;
            const options = { limit: 100 }; // Discord API limit
            if (lastId) options.before = lastId;
            
            try {
                console.log(`[TRANSCRIPT]: Fetching batch #${batchNumber}...`);
                const messages = await channel.messages.fetch(options);
                if (messages.size === 0) break;
                
                fetchedMessages.push(...messages.values());
                lastId = messages.last()?.id;
                if (!lastId) break; // Break if we can't get the last message ID
                
                totalFetched += messages.size;
                
                console.log(`[TRANSCRIPT]: Batch #${batchNumber} - Got ${messages.size} messages, total: ${totalFetched}`);
                if (messages.size < 100) break;
            } catch (fetchError) {
                console.error(`[TRANSCRIPT]: Error fetching batch #${batchNumber}:`, fetchError);
                break;
            }
        }

        console.log(`[TRANSCRIPT]: Completed fetch for #${channel.name} - ${totalFetched} messages retrieved`);

        // Sort messages chronologically
        fetchedMessages.sort((a, b) => a.createdTimestamp - b.createdTimestamp);

        // Add channel creation info with actual timestamp
        html += `<div class="system-message">
            <span>Channel was created on ${formatDate(channel.createdTimestamp)}</span>
        </div>`;

        // Process messages more efficiently by grouping
        let currentUser = null;
        let currentMessages = [];

        for (const message of fetchedMessages) {
            try {
                if (currentUser !== message.author.id) {
                    if (currentMessages.length > 0) {
                        html += processMessageGroup(currentMessages);
                        currentMessages = [];
                    }
                    currentUser = message.author.id;
                }
                currentMessages.push(message);
            } catch (error) {
                console.error('[TRANSCRIPT]: Error processing message for grouping:', error);
                // Skip this message and continue
            }
        }
        
        if (currentMessages.length > 0) {
            html += processMessageGroup(currentMessages);
        }

        // Add a handler for missing avatar URLs
        function getAvatarUrl(user) {
            try {
                return user.displayAvatarURL({ size: 128 });
            } catch {
                return 'https://archive.org/download/discordprofilepictures/discordblue.png'; // Default Discord avatar
            }
        }

        // Escape HTML function for security
        function escapeHTML(text) {
            if (!text) return '';
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }
        
        // Format file size function
        function formatFileSize(bytes) {
            if (!bytes || isNaN(bytes)) return '0 B';
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.min(Math.floor(Math.log(bytes) / Math.log(1024)), 4); // Max out at TB
            return `${(bytes / Math.pow(1024, i)).toFixed(2)} ${sizes[i]}`;
        }

        // Improved message group processor with hover effects and timestamps
        function processMessageGroup(messages) {
            if (!messages.length) return '';
            
            try {
                const author = messages[0].author;
                const timestamp = messages[0].createdTimestamp;
                
                // Safety check for author - use a default if missing
                if (!author) {
                    return `<div class="system-message">[Message with missing author data]</div>`;
                }
                
                let groupHTML = `<div class="message-container" data-user-id="${escapeHTML(author.id)}" id="msg-${escapeHTML(messages[0].id)}">
                    <div class="message-header">
                        <img src="${getAvatarUrl(author)}" alt="${escapeHTML(author.username || 'Unknown')}'s avatar" 
                             onerror="this.onerror=null;this.src='https://discord.com/assets/5fb477ca84edd15d9a2888765a7fe30c.png';">
                        <span class="username">${escapeHTML(author.username || 'Unknown User')}</span>`;
                        
                if (author.bot) {
                    groupHTML += `<span class="bot-tag">BOT</span>`;
                }
                
                // More detailed timestamp with absolute & relative time
                let dateStr = 'Unknown Date';
                try {
                    // eslint-disable-next-line no-unused-vars
                    const date = new Date(timestamp);
                    dateStr = formatDate(timestamp);
                } catch {
                    // Invalid date
                }
                
                groupHTML += `
                    <span class="timestamp" title="${dateStr}">
                        ${dateStr}
                    </span>
                </div>`;
                
                for (const message of messages) {
                    try {
                        // Skip messages without an ID
                        if (!message.id) continue;
                        
                        // Add message ID for linking
                        groupHTML += `<div id="msg-${escapeHTML(message.id)}">`;
                        
                        // Message content with empty check
                        if (message.content) {
                            groupHTML += `<div class="message-content">${markdownToHTML(message.content)}</div>`;
                        }
                        
                        // Embeds with error handling
                        if (message.embeds && Array.isArray(message.embeds) && message.embeds.length > 0) {
                            for (const embed of message.embeds) {
                                try {
                                    groupHTML += `<div class="message-content">${createEmbed(embed)}</div>`;
                                } catch (embedError) {
                                    console.error('[TRANSCRIPT]: Error processing embed:', embedError);
                                    groupHTML += `<div class="message-content" style="color: #a3a6aa;">[Embed could not be displayed]</div>`;
                                }
                            }
                        }
                        
                        // Attachments with better error handling and previews
                        if (message.attachments && message.attachments.size > 0) {
                            message.attachments.forEach(attachment => {
                                try {
                                    // Skip attachments without URLs
                                    if (!attachment.url) {
                                        groupHTML += `<div class="message-content" style="color: #a3a6aa;">[Attachment without URL]</div>`;
                                        return;
                                    }
                                    
                                    const fileName = attachment.name || 'Attachment';
                                    const fileSize = formatFileSize(attachment.size);
                                    const fileUrl = attachment.url;
                                    
                                    // Check if attachment is an image type
                                    const isImage = attachment.contentType ? 
                                        attachment.contentType.startsWith('image/') :
                                        /\.(jpg|jpeg|png|gif|webp)$/i.test(attachment.name || '');
                                        
                                    // Check if it's a GIF specifically
                                    const isGif = (attachment.contentType === 'image/gif') || 
                                        (attachment.name && attachment.name.toLowerCase().endsWith('.gif'));

                                    // For images and GIFs in closed channels, show link instead of embedding
                                    if (isImage) {
                                        groupHTML += `
                                            <div class="message-attachment">
                                                <div class="attachment-file image-attachment-link">
                                                    <a href="${fileUrl}" target="_blank" rel="noopener">
                                                        ${isGif ? '🎞️' : '🖼️'} ${escapeHTML(fileName)} (${fileSize})
                                                    </a>
                                                    <div class="attachment-note">Image may no longer be available - click to view original URL</div>
                                                </div>
                                            </div>`;
                                    } else {
                                        // For non-image files, keep current approach
                                        // Get file extension to show appropriate icon
                                        const extension = fileName.split('.').pop().toLowerCase();
                                        let fileIcon = '📄'; // Default file icon
                                        
                                        if (['zip', 'rar', '7z', 'tar', 'gz'].includes(extension)) fileIcon = '🗜️';
                                        else if (['mp3', 'wav', 'ogg', 'm4a'].includes(extension)) fileIcon = '🎵';
                                        else if (['mp4', 'webm', 'mov', 'avi'].includes(extension)) fileIcon = '🎬';
                                        else if (['pdf'].includes(extension)) fileIcon = '📕';
                                        else if (['doc', 'docx'].includes(extension)) fileIcon = '📘';
                                        else if (['xls', 'xlsx'].includes(extension)) fileIcon = '📗';
                                        else if (['ppt', 'pptx'].includes(extension)) fileIcon = '📙';
                                        else if (['txt', 'log', 'md'].includes(extension)) fileIcon = '📝';
                                        else if (['js', 'py', 'java', 'c', 'cpp', 'cs', 'html', 'css', 'php'].includes(extension)) fileIcon = '💻';
                                        
                                        groupHTML += `
                                            <a class="message-attachment attachment-file" href="${fileUrl}" target="_blank">
                                                ${fileIcon} ${escapeHTML(fileName)} (${fileSize})
                                            </a>`;
                                    }
                                } catch (attachError) {
                                    console.error('[TRANSCRIPT]: Error processing attachment:', attachError);
                                    groupHTML += `<div class="message-content" style="color: #a3a6aa;">[Attachment could not be displayed]</div>`;
                                }
                            });
                        }
                        
                        // Interactive components representation with better error handling
                        if (message.components && Array.isArray(message.components) && message.components.length > 0) {
                            try {
                                groupHTML += `<div class="message-components">`;
                                
                                // Try to represent buttons visually
                                message.components.forEach(row => {
                                    if (row && row.components && Array.isArray(row.components)) {
                                        groupHTML += `<div class="component-row">`;
                                        row.components.forEach(comp => {
                                            try {
                                                // Fix button style colors to match Discord's actual colors
                                                if (comp && comp.type === 2) { // Button
                                                    let style = '';
                                                    // Accurate Discord button styles
                                                    switch(comp.style) {
                                                        case 1: style = 'background-color:#4f545c;'; break; // Secondary (gray)
                                                        case 2: style = 'background-color:#5865f2;'; break; // Primary (blue)
                                                        case 3: style = 'background-color:#43b581;'; break; // Success (green)
                                                        case 4: style = 'background-color:#f04747;'; break; // Danger (red)
                                                        case 5: style = 'background-color:transparent;border:1px solid #dcddde;'; break; // Link (transparent)
                                                        default: style = 'background-color:#4f545c;'; // Default (gray)
                                                    }
                                                    
                                                    const label = comp.label ? escapeHTML(comp.label) : 'Button';
                                                    
                                                    // For message components with emoji
                                                    if (comp && comp.type === 2) { // Button

                                                        // Better emoji handling for components
                                                        let emojiHtml = '';
                                                        if (comp.emoji) {
                                                            if (comp.emoji.id) {
                                                                const extension = comp.emoji.animated ? 'gif' : 'png';
                                                                const emojiUrl = `https://cdn.discordapp.com/emojis/${comp.emoji.id}.${extension}`;
                                                                emojiHtml = `<img class="component-emoji" src="${emojiUrl}" alt=":${comp.emoji.name || 'emoji'}:" style="width:16px;height:16px;vertical-align:middle;margin-right:4px;" onerror="this.onerror=null;this.style.display='none';this.parentNode.insertAdjacentText('afterbegin', ':${comp.emoji.name || ''}:');">`;
                                                            } else if (comp.emoji.name) {
                                                                emojiHtml = `${comp.emoji.name} `;
                                                            }
                                                        }
                                                        
                                                        groupHTML += `<button class="component-button" style="${style}" disabled>${emojiHtml}${label}</button>`;
                                                    }
                                                } else if (comp && comp.type === 3) { // Select Menu
                                                    groupHTML += `<span class="component-select">Dropdown menu</span>`;
                                                }
                                            } catch (compError) {
                                                console.error('[TRANSCRIPT]: Error processing component:', compError);
                                                groupHTML += `<span class="component-button">Error</span>`;
                                            }
                                        });
                                        groupHTML += `</div>`;
                                    }
                                });
                                
                                groupHTML += `</div>`;
                            } catch (compError) {
                                console.error('[TRANSCRIPT]: Error processing components:', compError);
                                groupHTML += `<div class="message-content" style="color: #a3a6aa;">[Components could not be displayed]</div>`;
                            }
                        }
                        
                        // Improved reaction rendering for message processing
                        if (message.reactions && message.reactions.cache.size > 0) {
                            groupHTML += '<div class="message-reactions">';
                            
                            message.reactions.cache.forEach(reaction => {
                                try {
                                    let emojiHtml;
                                    if (reaction.emoji.id) {
                                        // Custom emoji
                                        const extension = reaction.emoji.animated ? 'gif' : 'png';
                                        const emojiUrl = `https://cdn.discordapp.com/emojis/${reaction.emoji.id}.${extension}`;
                                        // Fix: Improve the error handler to correctly insert text
                                        emojiHtml = `<img class="reaction-emoji" src="${emojiUrl}" alt=":${reaction.emoji.name || 'emoji'}:" title=":${reaction.emoji.name || 'emoji'}:" onerror="this.onerror=null;this.style.display='none';this.parentNode.insertAdjacentText('beforeend', ':${reaction.emoji.name || 'emoji'}:');">`;
                                    } else {
                                        // Standard emoji - just output directly
                                        emojiHtml = reaction.emoji.name;
                                    }
                                    
                                    groupHTML += `
                                        <div class="reaction">
                                            <span>${emojiHtml}</span>
                                            <span class="reaction-count">${reaction.count}</span>
                                        </div>`;
                                } catch (emojiError) {
                                    console.error('[TRANSCRIPT]: Error rendering reaction:', emojiError);
                                }
                            });
                            
                            groupHTML += '</div>';
                        }
                        
                        groupHTML += `</div>`; // Close message div
                    } catch (messageError) {
                        console.error('[TRANSCRIPT]: Error processing message:', messageError);
                        groupHTML += `<div class="message-content" style="color: #ff5555;">[Message processing error]</div>`;
                    }
                }
                
                groupHTML += '</div>'; // Close message-container
                return groupHTML;
            } catch (groupError) {
                console.error('[TRANSCRIPT]: Error processing message group:', groupError);
                return `<div class="system-message">[Error displaying messages]</div>`;
            }
        }
        
        // Close HTML with some useful footer information
        html += `
            <div class="system-message">
                <span>End of transcript • Generated on ${formatDate(Date.now())}</span>
            </div>
            <div class="jump-section">
                <div class="jump-button" id="jumpToTop" title="Jump to top">
                    <svg width="24" height="24" viewBox="0 0 24 24">
                        <path fill="currentColor" d="M7.41,15.41L12,10.83L16.59,15.41L18,14L12,8L6,14L7.41,15.41Z"></path>
                    </svg>
                </div>
                <div class="jump-button" id="jumpToBottom" title="Jump to bottom">
                    <svg width="24" height="24" viewBox="0 0 24 24">
                        <path fill="currentColor" d="M7.41,8.58L12,13.17L16.59,8.58L18,16.58L12,22.58L6,16.58L7.41,8.58Z"></path>
                    </svg>
                </div>
            </div>
            <script>
                // Consolidated event handlers
                document.addEventListener('DOMContentLoaded', function() {
                    // Set up jump buttons
                    document.getElementById('jumpToTop')?.addEventListener('click', () => {
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                    });
                    
                    document.getElementById('jumpToBottom')?.addEventListener('click', () => {
                        window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
                    });
                    
                    // Handle spoiler tags
                    document.querySelectorAll('.spoiler').forEach(function(spoiler) {
                        spoiler.addEventListener('click', function() {
                            this.classList.toggle('revealed');
                        });
                    });
                    
                    // Unified image error handling
                    document.querySelectorAll('img').forEach(function(img) {
                        img.addEventListener('error', function handleImageError() {
                            // Remove the error handler to prevent loops
                            this.removeEventListener('error', handleImageError);
                            
                            // Check image type
                            if (this.classList.contains('discord-emoji') || this.classList.contains('reaction-emoji') || this.classList.contains('component-emoji')) {
                                // Handle emoji error
                                const emojiName = this.getAttribute('alt') || this.getAttribute('title') || '';
                                this.style.display = 'none';
                                if (emojiName) {
                                    this.parentNode.insertAdjacentText('beforeend', emojiName.replace(/:/g, ''));
                                }
                            } else if (this.classList.contains('attachment-gif') || (this.parentNode && this.parentNode.classList.contains('embed-gif'))) {
                                // Handle GIF error
                                this.style.display = 'none';
                                this.insertAdjacentHTML('afterend', '<div style="color:#ff5555;">[GIF no longer available]</div>');
                            } else {
                                // Handle regular image error
                                this.style.display = 'none';
                                this.insertAdjacentHTML('afterend', '<div style="color:#ff5555;">[Image no longer available]</div>');
                                
                                // Add note for embeds
                                const embedParent = this.closest('.embed');
                                if (embedParent) {
                                    const note = document.createElement('div');
                                    note.className = 'attachment-note';
                                    note.textContent = 'Image unavailable in closed ticket';
                                    this.parentNode.insertBefore(note, this.nextSibling);
                                }
                            }
                        });
                    });
                    
                    // Count failed images
                    let failedImages = 0;
                    const totalImages = document.querySelectorAll('img:not(.discord-emoji):not(.reaction-emoji):not(.component-emoji)').length;
                    
                    document.querySelectorAll('img:not(.discord-emoji):not(.reaction-emoji):not(.component-emoji)').forEach(img => {
                        if (!img.complete || img.naturalHeight === 0) {
                            failedImages++;
                        }
                    });
                    
                    // Show a summary if many images failed
                    if (failedImages > 5 && totalImages > 0) {
                        const summary = document.createElement('div');
                        summary.className = 'system-message';
                        summary.innerHTML = \`⚠️ \${failedImages} of \${totalImages} images could not be loaded because the ticket is closed.\`;
                        document.body.insertBefore(summary, document.body.firstChild.nextSibling);
                    }
                    
                    // Add notice for closed tickets
                    const header = document.querySelector('.transcript-info');
                    if (header) {
                        const notice = document.createElement('div');
                        notice.className = 'system-message';
                        notice.style.backgroundColor = 'rgba(255, 100, 100, 0.1)';
                        notice.style.marginTop = '10px';
                        notice.innerHTML = 'Note: This transcript is from a closed ticket. Some images and attachments may no longer be accessible.';
                        header.appendChild(notice);
                    }
                    
                    // Find and fix broken GIFs
                    document.querySelectorAll('img').forEach(function(img) {
                        const isGif = img.classList.contains('attachment-gif') || 
                                    img.hasAttribute('data-is-gif') ||
                                    (img.src && img.src.toLowerCase().endsWith('.gif')) ||
                                    (img.parentNode && img.parentNode.classList.contains('embed-gif'));
                        
                        if (isGif) {
                            const originalSrc = img.src;
                            const loadingId = 'gif-loading-' + Math.random().toString(36).substring(2, 15);
                            
                            if (originalSrc) {
                                img.insertAdjacentHTML('afterend', 
                                    '<div id="' + loadingId + '" style="text-align:center;padding:4px;color:#72767d;font-size:12px;">' +
                                        'Loading GIF...' +
                                    '</div>');
                                
                                // Force reload technique
                                const tempSrc = img.src;
                                img.src = '';
                                
                                // Wait a moment before restoring
                                setTimeout(function() {
                                    img.onload = function() {
                                        const loader = document.getElementById(loadingId);
                                        if (loader) loader.style.display = 'none';
                                    };
                                    
                                    img.src = tempSrc;
                                }, 50);
                            }
                        }
                    });
                });
            </script>`;

        // Return both formats with a more informative text transcript
        const textTranscript = `# Transcript for #${channel.name} (${channel.id})
Generated on ${formatDate(Date.now())}
Server: ${channel.guild.name}
Total messages: ${fetchedMessages.length}

${fetchedMessages
    .map(m => `[${formatDate(m.createdTimestamp)}] ${m.author.username}${m.author.bot ? ' [BOT]' : ''}: ${m.content || '[No text content]'}${
        m.attachments.size > 0 ? `\n  - Attachments: ${Array.from(m.attachments.values()).map(a => a.url).join(', ')}` : ''
    }${
        m.embeds.length > 0 ? '\n  - [Message contained embeds]' : ''
    }`)
    .join('\n\n')}

End of transcript`;
            
        return {
            text: textTranscript,
            html: html
        };
    } catch (error) {
        console.error('[ERR]: Error generating transcript:', error);
        // Improved fallback to simple text transcript
        let transcript = '** ERROR GENERATING HTML TRANSCRIPT **\n\n';
        transcript += `Error details: ${error.message}\n\n`;
        transcript += '** Simple text version provided: **\n\n';
        
        try {
            const messages = await channel.messages.fetch({ limit: 100 });
            transcript += `Channel: #${channel.name} (${channel.id})\n`;
            transcript += `Server: ${channel.guild.name}\n`;
            transcript += `Transcript generated: ${new Date().toLocaleString()}\n`;
            transcript += `Messages retrieved: ${messages.size}\n\n`;
            
            messages.sort((a, b) => a.createdTimestamp - b.createdTimestamp).forEach(message => {
                transcript += `[${new Date(message.createdTimestamp).toLocaleString()}] ${message.author.username}: ${message.content || '[No text content]'}\n`;
                if (message.attachments.size > 0) {
                    message.attachments.forEach(attachment => {
                        transcript += `  - Attachment: ${attachment.name || 'Unnamed'} (${attachment.url})\n`;
                    });
                }
                if (message.embeds.length > 0) {
                    transcript += `  - Message contained ${message.embeds.length} embed(s)\n`;
                }
            });
        } catch (fallbackError) {
            console.error('[ERR]: Error in fallback transcript generation:', fallbackError);
            transcript += '** Failed to fetch messages for transcript **\n';
            transcript += `Error details: ${fallbackError.message}`;
        }
        
        return {
            text: transcript,
            html: null
        };
    }
};